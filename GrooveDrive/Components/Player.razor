@using Microsoft.AspNetCore.Authorization
@using Microsoft.Graph
@using System.Text.Json
@attribute [Authorize]
@inject GraphServiceClient _graphClient
@inject PlayerState _playerState
@inject IJSRuntime _js

<div class="player">
    @if (_playerState.CurrentSong is not null)
    {
        <AlbumThumbnail ThumbnailUrl="@_playerState.CurrentSong.ThumbnailUrl" CssClass="fixed-bottom" />
        <div class="fixed-bottom bg-secondary w-100 w-md-auto d-flex flex-column p-2 current-song-info">
            <span class="fs-5">@_playerState.CurrentSong.GetTitle()</span>
            @if (!string.IsNullOrWhiteSpace(_playerState.CurrentSong.Artist))
            {
                <NavLink href="@($"/Artist/{_playerState.CurrentSong.Artist}")">
                    <strong class="fs-6">@_playerState.CurrentSong.Artist</strong>
                </NavLink>
            }
        </div>
    }
    else
    {
        <div class="album-thumbnail fixed-bottom"></div>
    }
    <div class="fixed-bottom d-flex flex-column flex-grow-1 bg-dark">
        <div class="d-flex justify-content-center p-3 player-menu">
            <button type="button" class="btn btn-link @(_playerState.Random ? "text-primary" : "text-light")" @onclick="@(() => _playerState.ToggleRandom())">
                <span class="oi oi-random"></span>
                <span class="visually-hidden">Random</span>
            </button>
            <button type="button" class="btn btn-link">
                <span class="oi oi-media-step-backward" @onclick="Previous"></span>
                <span class="visually-hidden">Random</span>
            </button>
            @if (_playerState.IsLoading)
            {
                <Spinner ExpandedAndCentered="false"/>
            }
            else {
                switch (_playerState.CurrentPlayState)
                {                
                    case PlayerStateType.Play:
                        <button type="button" class="btn btn-link" @onclick="Pause">
                            <span role="button" title="Pause" class="oi oi-media-pause"></span>
                            <span class="visually-hidden">Pause</span>
                        </button>
                        break;
                    case PlayerStateType.Pause:
                    case PlayerStateType.Stop:
                    case PlayerStateType.Unset:
                        <button type="button" class="btn btn-link" @onclick="Play">
                            <span role="button" title="Play" class="oi oi-media-play"></span>
                            <span class="visually-hidden">Play</span>
                        </button>
                        break;
                }
            }
            <button type="button" class="btn btn-link">
                <span role="button" title="Next" class="oi oi-media-step-forward" @onclick="Next"></span>
                <span class="visually-hidden">Next</span>
            </button>
            <button type="button" class="btn btn-link @(_playerState.Repeat ? "text-primary" : "text-light")" @onclick="@(() => _playerState.ToggleRepeat())">
                <span class="oi oi-loop-square"></span>
                <span class="visually-hidden">Loop</span>
            </button>
            <span>@currentTimeFormat</span>
            <span> of </span>
            <span>@durationFormat</span>
        </div>
        <div class="progress d-none d-md-flex" style="height: 3px;">
            <div class="progress-bar" role="progressbar" aria-valuenow="@progress" aria-valuemin="0" aria-valuemax="100" style="width: @(progress)%; transition: 2.5s linear;"></div>
        </div>
        <audio id="player" controls="controls" class="w-100 d-md-none" autoplay="autoplay" loop="@(_playerState.AllSongs?.Count() == 1 && _playerState.Repeat)" onended="@(_playerState.Repeat ? "DotNet.invokeMethod('GrooveDrive', 'NextTrackInvokable')" : "")" ontimeupdate="DotNet.invokeMethod('GrooveDrive', 'UpdateProgressInvokable', this.currentTime, this.duration)"></audio>
    </div>
</div>

@code {
    private static Action? _nextTrackAction;
    private static Action<float, float>? _updateProgressAction;
    private float _currentTime = 0;
    private float _duration = 0;
    private TimeSpan t1 => TimeSpan.FromSeconds(_duration);
    private TimeSpan t2 => TimeSpan.FromSeconds(_currentTime);
    private string durationFormat => string.Format("{1:D2}:{2:D2}", t1.Hours, t1.Minutes, t1.Seconds, t1.Milliseconds);
    private string currentTimeFormat => string.Format("{1:D2}:{2:D2}", t2.Hours, t2.Minutes, t2.Seconds, t2.Milliseconds);
    private int progress => (int)((Math.Round(_currentTime) * 100) / Math.Round(_duration));

    private async Task StreamCurrentSong()
    {
        if (_playerState.CurrentSong is not null)
        {
            var fileStream = await _graphClient.Me.Drive.Items[_playerState.CurrentSong.DriveId].Content
                .Request()
                .GetAsync();
            using var streamRef = new DotNetStreamReference(stream: fileStream);
            await _js.InvokeVoidAsync("GrooveDrive.streamItem", streamRef);
        }
    }

    private void UpdateProgress(float currentTime, float duration)
    {
        _currentTime = currentTime;
        _duration = duration;
        StateHasChanged();
    }

    private void Play()
    {
        _playerState.Play();
        _js.InvokeVoidAsync("GrooveDrive.play");
    }

    private void Pause()
    {
        _playerState.Pause();
        _js.InvokeVoidAsync("GrooveDrive.pause");
    }

    private void Next()
    {
        _playerState.NextTrack();
    }

    private void Previous()
    {
        _playerState.PreviousTrack();
    }

    [JSInvokable]
    public static void UpdateProgressInvokable(float currentTime, float duration)
    {
        _updateProgressAction?.DynamicInvoke(currentTime, duration);
    }

    [JSInvokable]
    public static void NextTrackInvokable()
    {
        _nextTrackAction?.Invoke();
    }

    protected override void OnInitialized()
    {
        _playerState.OnChange += StateHasChanged;
        _playerState.OnStreamChange += StreamCurrentSong;
        _nextTrackAction += Next;
        _updateProgressAction += UpdateProgress;
    }
}
